#!/bin/ksh

#--------------------------------------------------------------------------------------------------
# Copyright (c) 2017 Fernando Nunes
# License: This script is licensed as Apache ( http://www.apache.org/licenses/LICENSE-2.0.html )
# $Author: Fernando Nunes - domusonline@gmail.com $
# $Revision: 1.0.22 $
# $Date 2017-04-26 14:39:50$
# Disclaimer: This software is provided AS IS, without any kind of guarantee. Use at your own risk.
#--------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Function definitions
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# show command syntax
#------------------------------------------------------------------------------

show_help()
{
	echo "${PROGNAME}: -V | -h | {-I INST -H host -u host_user -k ssh_key [-s sub1,sub2[,sub3...] [-o oldest_tx.log]}"
	echo "               -V shows script version"
	echo "               -h shows this help"
	echo "               -I INST          : check bookmark against instance INST"
	echo "               -H host          : obtain bookmarks from host"
	echo "               -u host_user     : use host_user for host SSH authentication"
	echo "               -k ssh_key       : use SSH ssh_key private key"
	echo "               -s sub1,sub2...  : check this list of subs"
	echo "               -o logfile       : log file containing the oldest open transaction logs as generated by get_oldest_n_transaction.sh script"
	echo "Ex: ${PROGNAME} -I INSTSRC01 -H target_machine -k target_machine_key -s SUB1"
}

#------------------------------------------------------------------------------
# parse the arguments using standard getopts function
#------------------------------------------------------------------------------
get_args()
{
	arg_ok="Vhs:I:H:u:k:s:T:"
	while getopts ${arg_ok} OPTION
	do
		case ${OPTION} in
		h)   # show help
			show_help
			exit 0
			;;
		V)      #show version
			echo "${PROGNAME} ${VERSION}" >&1
			exit 0
			;;
		H)      #host
			TARGET_HOST_FLAG=1
			TARGET_HOST=$OPTARG	
			echo ${TARGET_HOST} | grep "^[a-zA-Z][0-9a-zA-Z\.-]*$" >/dev/null
			if [ $? != 0 ]
			then
				log ERROR "$$ Syntax error - Invalid target hostname (${TARGET_HOST})"
				return 1
			fi
			;;
		u)      #user name
			TARGET_USER_FLAG=1
			TARGET_USER=$OPTARG	
			echo ${TARGET_USER} | grep "^[a-zA-Z][0-9a-zA-Z\.-]*$" >/dev/null
			if [ $? != 0 ]
			then
				log ERROR "$$ Syntax error - Invalid target username (${TARGET_USER})"
				return 1
			fi
			;;
		k)      #ssh key
			TARGET_KEY_FLAG=1
			TARGET_KEY=$OPTARG	
			echo ${TARGET_KEY} | grep "^[a-zA-Z][0-9a-zA-Z\.-]*$" >/dev/null
			if [ $? != 0 ]
			then
				log ERROR "$$ Syntax error - Invalid target ssh key name (${TARGET_KEY})"
				return 1
			else
				if [ ! -f ~/.ssh/${TARGET_KEY} ]
				then
					log ERROR "$$ target key (~/.ssh/${TARGET_KEY}) does not exist"
					return 1
				else
					if [ ! -r ~/.ssh/${TARGET_KEY} ]
					then
						log ERROR "$$ target key (~/.ssh/${TARGET_KEY}) can't be read"
						return 1
					fi
				fi
			fi
			;;
                l)      #log filename
			OLDEST_LOG_FILE_FLAG=1
			OLDEST_LOG_FILE=${OPTARG}
			echo ${OLDEST_LOG_FILE} | grep "/" > /dev/null
			if [ $? = 0 ]
			then
				log ERROR "$$ Log filename (${OLDEST_LOG_FILE}) must not contain directories"
				return 1
			else
				OLDEST_LOG_FILE=${LOG_DIR}/${OLDEST_LOG_FILE}
			fi
			;;
		T)   # set up the -T instance
			TARGET_INSTANCE_FLAG=1
			TARGET_INSTANCE=$OPTARG
			;;
		I)   # set up the -I instance
			INSTANCE_FLAG=1
			INSTANCE=$OPTARG
			echo ${INSTANCE} | grep "," > /dev/null
			if [ $? = 0 ]
			then
				#More than one instance was provided. Can't accept subscriptions!
				if [ "X${SUBSCRIPTION_FLAG}" = "X1" ]
				then
					log ERROR "$$ Syntax error - Multiple instances can't be provided with the -s option"
					return 1
				else
					INSTANCE_FLAG=2
				fi
			fi
			#instanceIsActive $INSTANCE
			#RES=$?
			#if [ "X${RES}" != "X0" ]
			#then
			#       echo "${PROGNAME}: Instance $INSTANCE does not exist or is not active" >&2
			#       return 1
			#fi
			;;
		s)   # set up the locked subscriptions
			if [ "X${INSTANCE_FLAG}" = "X2" ]
			then
				log ERROR "$$ Syntax error - The -s option can't be specified with multiple instances"
				return 1
			fi
			SUBSCRIPTION_FLAG=1
			SUBSCRIPTION=$OPTARG
			echo ${SUBSCRIPTION} | egrep "^[a-zA-Z][a-zA-Z0-9\-_]*(,[a-zA-Z][a-zA-Z0-9\-_])*" 1>/dev/null 2>/dev/null
			RES=$?
			if [ "X${RES}" != "X0" ]
			then
				log ERROR "$$ Syntax error - Subscription(s) (${SUBSCRIPTION}) is invalid" >&2
				return 1
			fi
			;;
		*)
			log ERROR "$$ Invalid parameter (${OPTION}) given"
			return 1
			;;
		esac
	done
}

#------------------------------------------------------------------------------
# Cleaning up temp files
#------------------------------------------------------------------------------
clean_up()
{
	rm -f $TEMP_FILE_MAIL $TEMP_FILE_BODY $ALERT_FILE $TEMP_FILE_AWK
}

#------------------------------------------------------------------------------
# Create a temp AWK script to parse a dmshowbookmark output
#------------------------------------------------------------------------------
create_awk()
{
	cat <<EOF! > $TEMP_FILE_AWK
BEGIN {
RESTART_POSITION="na"
COMMIT_POSITION="na"
}

/Restart position/ {
RESTART_POSITION=\$3
}

/Commit position/ {
split(\$3,ARR,"\.")
COMMIT_POSITION=ARR[1]
}
END {
print RESTART_POSITION " " COMMIT_POSITION
}
EOF!
}

#------------------------------------------------------------------------------
# Send an email alert
#------------------------------------------------------------------------------
alert_mail()
{
	BODY_TYPE=$1
	case $BODY_TYPE in
	PARAM)
		shift
		BODY=$1
	        ${SENDMAIL_COMMAND} ${SENDMAIL_OPTIONS} <<EOF
FROM: $ALARM_FROM
TO: $ALARM_TO
CC: $ALARM_CC
SUBJECT: $ALARM_SUBJECT
----------------------------------------------------------
$BODY
----------------------------------------------------------
.
EOF
		;;
	FILE)
		cat <<EOF! > $TEMP_FILE_MAIL
FROM: $ALARM_FROM
TO: $ALARM_TO
CC: $ALARM_CC
SUBJECT: $ALARM_SUBJECT
----------------------------------------------------------
EOF!
		cat $TEMP_FILE_BODY >> $TEMP_FILE_MAIL
		cat <<EOF! >> $TEMP_FILE_MAIL

----------------------------------------------------------
.
EOF!

		${SENDMAIL_COMMAND} ${SENDMAIL_OPTIONS} < $TEMP_FILE_MAIL
		;;
	*)
		log WARNING "$$ Invalid body type in alert_email()"
	esac

}


#------------------------------------------------------------------------------
# Obtain a UNIX timestamp from an Oracle SCN
#------------------------------------------------------------------------------
get_scn_ts()
{
	POSITION=$1
	TYPE=$2
	LOG_TYPE=$3

	case $TYPE in
	MIN)
		FIELD_INDEX=2
		break
		;;
	MAX)
		FIELD_INDEX=3
		break
		;;
	*)
		log ERROR "$$ get_scn_ts(): INVALID parameter for type ($TYPE). Exiting!"
		exit 1
		;;
	esac

	case $LOG_TYPE in
	ARCH)
		sqlplus -s $ORA_U/$ORA_P <<EOF | grep "^OUTPUT" | awk -F'|' -v FIELD_INDEX=$FIELD_INDEX 'BEGIN {STOP_POSITION="na"} {STOP_POSITION=$FIELD_INDEX} END {print STOP_POSITION}' | read STOP_POSITION
set colsep '|'
set linesize 200
set pagesize 0
set sqlprompt ''
set trimspool on
set headsep off
	ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD HH24:MI:SS';
	SELECT 
		'OUTPUT',
		(first_time - TO_DATE('1970-01-01', 'YYYY-MM-DD')) * 86400,
		(next_time - TO_DATE('1970-01-01', 'YYYY-MM-DD')) * 86400
	FROM
		v\$archived_log
	WHERE
		$POSITION BETWEEN first_change# AND next_change# AND
		dest_id = $ORACLE_DEST_ID;
EOF
		;;
	ONLN)
		sqlplus -s $ORA_U/$ORA_P <<EOF | grep "^OUTPUT" | awk -F'|' -v FIELD_INDEX=$FIELD_INDEX 'BEGIN {STOP_POSITION="na"} {STOP_POSITION=$FIELD_INDEX} END {print STOP_POSITION}' | read STOP_POSITION
set colsep '|'
set linesize 200
set pagesize 0
set sqlprompt ''
set trimspool on
set headsep off
	ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD HH24:MI:SS';
	SELECT 
		'OUTPUT',
		(first_time - TO_DATE('1970-01-01', 'YYYY-MM-DD')) * 86400
	FROM
		v\$log
	WHERE
		status = 'CURRENT' AND $POSITION >= first_change# ;
EOF
		;;
	esac
		
	echo $STOP_POSITION
}


TAIL_LIMIT=5000

#. ${DIR_PROGRAM}/.script_config.sh

#-------------------------------------------------
# Script START
#-------------------------------------------------
PROGNAME=`basename $0`
SCRIPT_DIR=`dirname $0`
VERSION=`echo "$Revision: 1.0.22 $" | cut -f2 -d' '`

TEMP_FILE_MAIL=/tmp/${PROGNAME}_mail_$$.tmp
TEMP_FILE_BODY=/tmp/${PROGNAME}_body_$$.tmp
TEMP_FILE_AWK=/tmp/${PROGNAME}_awk_$$.tmp
trap clean_up 0


# Read the settings from the properties file
if [ -x ${SCRIPT_DIR}/conf/cdc.properties ]
then
        . ${SCRIPT_DIR}/conf/cdc.properties
else
        log ERROR "$$ Cannot include properties file (${SCRIPT_DIR}/conf/cdc.properties). Exiting!"
        exit 1
fi

# Import general functions
if [ -x  "${SCRIPT_DIR}/include/functions.sh" ]
then
        . "${SCRIPT_DIR}/include/functions.sh"
else
        log ERROR "$$ Cannot include functions file (${SCRIPT_DIR}/include/functions.sh). Exiting!"
        exit 1
fi

NUM_ARGUMENTS=$#

get_args $*
if [ $? != 0 ]
then
        show_help >&2
        log ERROR "$$ Invalid parameters. Exiting!"
        exit 1
fi

if [ -f ${SCRIPT_DIR}/.oracle_env.sh ]
then
	. ${SCRIPT_DIR}/.oracle_env.sh
fi

ALARM_SUBJECT="Bookmark issue in instance $INSTANCE_NAME. Check body for details."

create_awk
trap clean_up 0


if [ "X${INSTANCE_FLAG}" = "X" ]
then
	#no instances were provided. Get a list of the instances
	INSTANCES_LIST=`retrieveDefinedInstances`
	if [ $? != 0 ]
	then
		log ERROR "$$ Couldn't get a list of instances. Exiting!"
		exit 1
	fi
else
	#One or more instances were provided
	if [ "X${INSTANCE_FLAG}" = "X1" ]
	then
		INSTANCE_LIST=$INSTANCE
		#one instance was provided. Did we also get the subscription list?
		if [ "X${SUBSCRIPTION_FLAG}" = "X" ]
		then
			SUBSCRIPTION_LIST=`generate_subs_list $INSTANCE Running`
			if [ $? != 0 ]
			then
				log ERROR "$$ Couldn't get a list of running subscriptions for instance ${INSTANCE_LIST}. Exiting!"
				exit 1
			fi
		fi
	else
		if [ "X${INSTANCE_FLAG}" = "X2" ]
		then
			#we gto multiple instances
			INSTANCE_LIST=`echo $INSTANCE | sed 's/,//g'`
		else
			log ERROR "$$ Invalid value for INSTANCE_FLAG. Exiting"
			exit 1
		fi
	fi
fi
		


DEBUG=0

BOOKMARK_COMMAND=`eval "echo \$SHOWBOOKMARK_COMMAND_${TARGET_INSTANCE}"`
if [ "X${BOOKMARK_COMMAND}" = "X" ]
then
	BOOKMARK_COMMAND=${SHOWBOOKMARK_COMMAND}
	if [ "X${BOOKMARK_COMMAND}" = "X" ]
	then
		log ERROR "$$ Could not obtain SHOWBOOKMARK_COMMAND for target instance (${TARGET_INSTANCE}). Exiting!"
		exit 1
	fi
fi

	

for INSTANCE_NAME in $INSTANCE_LIST
do
	ALERT_FILE=${SCRIPT_DIR}/tmp/${PROGNAME}_${INSTANCE_NAME}
	ALERT_FLAG=0

	if [ "X${OLDEST_LOG_FILE_FLAG}" = "X" ]
	then
		OLDEST_LOG_FILE=`eval "echo \$CDC_OLDEST_TX_LOGFILE_${INSTANCE_NAME}"`
		if [ "X${OLDEST_LOG_FILE}" = "X" ]
		then
			OLDEST_LOG_FILE=${CDC_OLDEST_TX_LOGFILE}
			if [ "X${OLDEST_LOG_FILE}" = "X" ]
			then
				log ERROR "$$ Could not obtain oldest open transaction log file for source instance (${INSTANCE_NAME}). Exiting!"
				exit 1
			fi
		fi
	fi

	ORACLE_DEST_ID=`eval "echo \$CDC_ORACLE_DEST_ID_${INSTANCE_NAME}"`
	if [ "X${ORACLE_DEST_ID}" = "X" ]
	then
		ORACLE_DEST_ID=${CDC_ORACLE_DEST_ID}
		if [ "X${ORACLE_DEST_ID}" = "X" ]
		then
			log ERROR "$$ Could not obtain ORACLE_DEST_ID for source instance (${INSTANCE_NAME}). Exiting!"
			exit 1
		fi
	fi
	if [ "X${SUBSCRIPTION_FLAG}" = "X" ]
	then
		SUBSCRIPTION_LIST=`generate_subs_list $INSTANCE Running`
		if [ $? != 0 ]
		then
			log ERROR "$$ Couldn't get a list of running subscriptions for instance ${INSTANCE_LIST}. Exiting!"
			exit 1
		fi

	log INFO "$$ Starting bookmark checking for instance ${INSTANCE_NAME}. Subscriptions: ${SUBSCRIPTION_LIST}"
	for SUBSCRIPTION in $SUBSCRIPTION_LIST
	do
		if [ $SUBSCRIPTION = "na" ]
		then
			break
		fi
		CURRENT_DATE=`date +"%Y-%m-%d %H:%M:%S"`

		ssh -i ~/.ssh/${TARGET_KEY} ${TARGET_USER}@${TARGET_HOST} ${BOOKMARK_COMMAND} -I ${TARGET_INSTANCE} -s ${SUBSCRIPTION} -v |  awk -f $TEMP_FILE_AWK | read RESTART_POSITION COMMIT_POSITION

		if [ "X${RESTART_POSITION}" = "Xna" -o "X${COMMIT_POSITION}" = "Xna" ]
		then
			log INFO "$$ Subscription ${SUBSCRIPTION} has no bookmark!" 
			continue
		fi
		log INFO "$$ Subscription: ${SUBSCRIPTION} Restart Position: ${RESTART_POSITION} Commit Position: ${COMMIT_POSITION}"
		get_scn_ts $RESTART_POSITION MAX ARCH | read TXSTART_STOP_INTERVAL

		if [ $DEBUG = 1 ];then log DEBUG "$$ Epoch restart position: ${TXSTART_STOP_INTERVAL}";fi

		tail -${TAIL_LIMIT} ${OLDEST_LOG_FILE} | awk -F '|' -v TXSTART_STOP_INTERVAL=${TXSTART_STOP_INTERVAL} '
BEGIN {
	COMMIT_STOP_INTERVAL="na"
}
{
	if ( $6 > TXSTART_STOP_INTERVAL )
	{
		COMMIT_STOP_INTERVAL=$2
		exit
	}
}

END {
print COMMIT_STOP_INTERVAL
}' | read COMMIT_STOP_INTERVAL

		if [ $DEBUG = 1 ];then log DEBUG "$$ Epoch commit stop interval: ${COMMIT_STOP_INTERVAL}";fi

		if [ "X${COMMIT_STOP_INTERVAL}" = "Xna" ]
		then
			log "$$ Bookmark OK!"
			continue
		fi

		get_scn_ts $COMMIT_POSITION MIN ARCH | read COMMIT_POSITION_STOP_INTERVAL
		if [ $DEBUG = 1 ];then log DEBUG "$$ Epoch commit position stop interval: ${COMMIT_POSITION_STOP_INTERVAL}";fi
		if [ "X${COMMIT_POSITION_STOP_INTERVAL}" = "Xna" ]
		then
			# initial ts from archived logs not found. Reading online logs
			get_scn_ts $COMMIT_POSITION MIN ONLN | read COMMIT_POSITION_STOP_INTERVAL
			if [ "X${COMMIT_POSITION_STOP_INTERVAL}" = "Xna" ]
			then
				log WARNING "$$ Bookmark issue 1! Subscription online,  TX from restart position already closed and it was not possible to get current log start position"
			else
				if [ ${COMMIT_POSITION_STOP_INTERVAL} -gt ${COMMIT_STOP_INTERVAL} ]
				then
					log WARNING "${CURRENT_DATE} Bookmark issue 2a! Commit stop interval: ${COMMIT_STOP_INTERVAL} Commit position stop interval: ${COMMIT_POSITION_STOP_INTERVAL}"
					echo "${CURRENT_DATE} Subscription $SUBSCRIPTION seems to have a stuck bookmark:" >> $TEMP_FILE_BODY
					echo "${CURRENT_DATE}      Restart Position: $RESTART_POSITION" >> $TEMP_FILE_BODY
					echo "${CURRENT_DATE}      Commit Position : $COMMIT_POSITION" >> $TEMP_FILE_BODY
					echo "${CURRENT_DATE}      Commit end interval         : $COMMIT_STOP_INTERVAL" >> $TEMP_FILE_BODY
					echo "${CURRENT_DATE}      Commit position end interval: $COMMIT_POSITION_STOP_INTERVAL" >> $TEMP_FILE_BODY
					printf "\n\n\n" >>$TEMP_FILE_BODY
					ALERT_FLAG=1
				else
					log INFO "$$ Bookmark ok(2)! Commit stop interval: ${COMMIT_STOP_INTERVAL} Commit position stop interval: ${COMMIT_POSITION_STOP_INTERVAL}"
				fi
			fi
		else
			if [ ${COMMIT_POSITION_STOP_INTERVAL} -gt ${COMMIT_STOP_INTERVAL} ]
			then
				log WARNING "$$ Bookmark issue2b! Commit stop interval: ${COMMIT_STOP_INTERVAL} Commit position stop interval: ${COMMIT_POSITION_STOP_INTERVAL}"
				echo "${CURRENT_DATE} Subscription $SUBSCRIPTION seems to have a stuck bookmark:" >> $TEMP_FILE_BODY
				echo "${CURRENT_DATE}      Restart Position: $RESTART_POSITION" >> $TEMP_FILE_BODY
				echo "${CURRENT_DATE}      Commit Position : $COMMIT_POSITION" >> $TEMP_FILE_BODY
				echo "${CURRENT_DATE}      Commit end interval         : $COMMIT_STOP_INTERVAL" >> $TEMP_FILE_BODY
				echo "${CURRENT_DATE}      Commit position end interval: $COMMIT_POSITION_STOP_INTERVAL" >> $TEMP_FILE_BODY
				printf "\n\n\n" >>$TEMP_FILE_BODY
				ALERT_FLAG=1
			else
				log INFO "${CURRENT_DATE} Bookmark ok! Commit stop interval: ${COMMIT_STOP_INTERVAL} Commit position stop interval: ${COMMIT_POSITION_STOP_INTERVAL}"
			fi
		fi
	done

	if [ $ALERT_FLAG = 1 ]
	then
		if [ -r "$ALERT_FILE" ]
		then
			cat $ALERT_FILE | read ALERT_COUNT	
			ALERT_COUNT=`expr $ALERT_COUNT + 1`
		else
			ALERT_COUNT=1
		fi
		if [ $ALERT_COUNT -le $ALERT_LIMIT ]
		then
			alert_mail FILE
		fi
		echo $ALERT_COUNT > $ALERT_FILE
	else
		rm -f $ALERT_FILE
	fi
	log INFO "$$ Finished bookmark checking for instance $INSTANCE_NAME"
done

