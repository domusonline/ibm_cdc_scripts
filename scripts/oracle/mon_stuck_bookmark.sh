#!/bin/ksh

#--------------------------------------------------------------------------------------------------
# Copyright (c) 2017 Fernando Nunes
# License: This script is licensed as Apache ( http://www.apache.org/licenses/LICENSE-2.0.html )
# $Author: Fernando Nunes - domusonline@gmail.com $
# $Revision: 1.0.41 $
# $Date 2017-04-27 15:09:02$
# Disclaimer: This software is provided AS IS, without any kind of guarantee. Use at your own risk.
#--------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Function definitions
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# show command syntax
#------------------------------------------------------------------------------

show_help()
{
	echo "${PROGNAME}: -V | -h | {-I INST -H host -u host_user -k ssh_key [-s sub1,sub2[,sub3...] [-o oldest_tx.log]}"
	echo "               -V shows script version"
	echo "               -h shows this help"
	echo "               -I INST          : check bookmark against instance INST"
	echo "               -H host          : obtain bookmarks from host"
	echo "               -u host_user     : use host_user for host SSH authentication"
	echo "               -k ssh_key       : use SSH ssh_key private key"
	echo "               -s sub1,sub2...  : check this list of subs"
	echo "               -o logfile       : log file containing the oldest open transaction logs as generated by get_oldest_n_transaction.sh script"
	echo "Ex: ${PROGNAME} -I INSTSRC01 -H target_machine -k target_machine_key -s SUB1"
}

#------------------------------------------------------------------------------
# parse the arguments using standard getopts function
#------------------------------------------------------------------------------
get_args()
{
	arg_ok="Vhs:I:H:u:k:o:T:"
	while getopts ${arg_ok} OPTION
	do
		case ${OPTION} in
		h)   # show help
			show_help
			exit 0
			;;
		V)      #show version
			echo "${PROGNAME} ${VERSION}" >&1
			exit 0
			;;
		H)      #host
			TARGET_HOST_FLAG=1
			TARGET_HOST=$OPTARG	
			echo ${TARGET_HOST} | grep "^[a-zA-Z][0-9a-zA-Z\.-]*$" >/dev/null
			if [ $? != 0 ]
			then
				log ERROR "$$ Syntax error - Invalid target hostname (${TARGET_HOST})"
				return 1
			fi
			;;
		u)      #user name
			TARGET_USER_FLAG=1
			TARGET_USER=$OPTARG	
			echo ${TARGET_USER} | grep "^[a-zA-Z][0-9a-zA-Z\.-]*$" >/dev/null
			if [ $? != 0 ]
			then
				log ERROR "$$ Syntax error - Invalid target username (${TARGET_USER})"
				return 1
			fi
			;;
		k)      #ssh key
			TARGET_KEY_FLAG=1
			TARGET_KEY=$OPTARG	
			echo ${TARGET_KEY} | grep "^[a-zA-Z][0-9a-zA-Z\._-]*$" >/dev/null
			if [ $? != 0 ]
			then
				log ERROR "$$ Syntax error - Invalid target ssh key name (${TARGET_KEY})"
				return 1
			else
				if [ ! -f ~/.ssh/${TARGET_KEY} ]
				then
					log ERROR "$$ target key (~/.ssh/${TARGET_KEY}) does not exist"
					return 1
				else
					if [ ! -r ~/.ssh/${TARGET_KEY} ]
					then
						log ERROR "$$ target key (~/.ssh/${TARGET_KEY}) can't be read"
						return 1
					fi
				fi
			fi
			;;
                o)      #log filename
			OLDEST_LOG_FILE_FLAG=1
			OLDEST_LOG_FILE=${OPTARG}
			echo ${OLDEST_LOG_FILE} | grep "/" > /dev/null
			if [ $? = 0 ]
			then
				log ERROR "$$ Log filename (${OLDEST_LOG_FILE}) must not contain directories"
				return 1
			else
				OLDEST_LOG_FILE=${LOG_DIR}/${OLDEST_LOG_FILE}
			fi
			;;
		T)   # set up the -T instance
			TARGET_INSTANCE_FLAG=1
			TARGET_INSTANCE=$OPTARG
			;;
		I)   # set up the -I instance
			INSTANCE_FLAG=1
			INSTANCE=$OPTARG
			echo ${INSTANCE} | grep "," > /dev/null
			if [ $? = 0 ]
			then
				#More than one instance was provided. Can't accept subscriptions!
				if [ "X${SUBSCRIPTION_FLAG}" = "X1" ]
				then
					log ERROR "$$ Syntax error - Multiple instances can't be provided with the -s option"
					return 1
				else
					INSTANCE_FLAG=2
				fi
			fi
			#instanceIsActive $INSTANCE
			#RES=$?
			#if [ "X${RES}" != "X0" ]
			#then
			#       echo "${PROGNAME}: Instance $INSTANCE does not exist or is not active" >&2
			#       return 1
			#fi
			;;
		s)   # set up the locked subscriptions
			if [ "X${INSTANCE_FLAG}" = "X2" ]
			then
				log ERROR "$$ Syntax error - The -s option can't be specified with multiple instances"
				return 1
			fi
			SUBSCRIPTION_FLAG=1
			SUBSCRIPTION_LIST=$OPTARG
			echo ${SUBSCRIPTION_LIST} | egrep "^[a-zA-Z][a-zA-Z0-9\-_]*(,[a-zA-Z][a-zA-Z0-9\-_])*" 1>/dev/null 2>/dev/null
			RES=$?
			if [ "X${RES}" != "X0" ]
			then
				log ERROR "$$ Syntax error - Subscription(s) (${SUBSCRIPTION_LIST}) is invalid" >&2
				return 1
			fi
			;;
		*)
			log ERROR "$$ Invalid parameter (${OPTION}) given"
			return 1
			;;
		esac
	done
	if [ ${NUM_ARGUMENTS} -ge ${OPTIND} ]
	then
		log ERROR "$$ Syntax error: Too many parameters" >&2
		return 2
	fi
        return 0
}

#------------------------------------------------------------------------------
# Cleaning up temp files
#------------------------------------------------------------------------------
clean_up()
{
	rm -f $TEMP_FILE_MAIL $TEMP_FILE_BODY $ALERT_FILE $TEMP_FILE_AWK
}

#------------------------------------------------------------------------------
# Create a temp AWK script to parse a dmshowbookmark output
#------------------------------------------------------------------------------
create_awk()
{
	cat <<EOF! > $TEMP_FILE_AWK
BEGIN {
RESTART_POSITION="na"
COMMIT_POSITION="na"
}

/Restart position/ {
RESTART_POSITION=\$3
}

/Commit position/ {
split(\$3,ARR,"\.")
COMMIT_POSITION=ARR[1]
}
END {
print RESTART_POSITION " " COMMIT_POSITION
}
EOF!
}

#------------------------------------------------------------------------------
# Send an email alert
#------------------------------------------------------------------------------
alert_mail()
{
	BODY_TYPE=$1
	case $BODY_TYPE in
	PARAM)
		shift
		BODY=$1
	        ${SENDMAIL} ${SENDMAIL_OPTIONS} <<EOF
FROM: $ALARM_FROM
TO: $ALARM_TO
CC: $ALARM_CC
SUBJECT: $ALARM_SUBJECT
----------------------------------------------------------
$BODY
----------------------------------------------------------
.
EOF
		;;
	FILE)
		cat <<EOF! > $TEMP_FILE_MAIL
FROM: $ALARM_FROM
TO: $ALARM_TO
CC: $ALARM_CC
SUBJECT: $ALARM_SUBJECT
----------------------------------------------------------
EOF!
		cat $TEMP_FILE_BODY >> $TEMP_FILE_MAIL
		cat <<EOF! >> $TEMP_FILE_MAIL

----------------------------------------------------------
.
EOF!

		${SENDMAIL} ${SENDMAIL_OPTIONS} < $TEMP_FILE_MAIL
		;;
	*)
		log WARNING "$$ Invalid body type in alert_email()"
	esac

}


#------------------------------------------------------------------------------
# Obtain a UNIX timestamp from an Oracle SCN
#------------------------------------------------------------------------------
get_scn_ts()
{
	POSITION=$1
	TYPE=$2
	LOG_TYPE=$3

	case $TYPE in
	MIN)
		FIELD_INDEX=2
		break
		;;
	MAX)
		FIELD_INDEX=3
		break
		;;
	*)
		log ERROR "$$ get_scn_ts(): INVALID parameter for type ($TYPE). Exiting!"
		exit 1
		;;
	esac

	case $LOG_TYPE in
	ARCH)
		sqlplus -s $ORA_U/$ORA_P <<EOF | grep "^OUTPUT" | awk -F'|' -v FIELD_INDEX=$FIELD_INDEX 'BEGIN {STOP_POSITION="na"} {STOP_POSITION=$FIELD_INDEX} END {print STOP_POSITION}' | read STOP_POSITION
set colsep '|'
set linesize 200
set pagesize 0
set sqlprompt ''
set trimspool on
set headsep off
	ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD HH24:MI:SS';
	SELECT 
		'OUTPUT',
		(first_time - TO_DATE('1970-01-01', 'YYYY-MM-DD')) * 86400,
		(next_time - TO_DATE('1970-01-01', 'YYYY-MM-DD')) * 86400
	FROM
		v\$archived_log
	WHERE
		$POSITION BETWEEN first_change# AND next_change# AND
		dest_id = $ORACLE_DEST_ID;
EOF
		;;
	ONLN)
		sqlplus -s $ORA_U/$ORA_P <<EOF | grep "^OUTPUT" | awk -F'|' -v FIELD_INDEX=$FIELD_INDEX 'BEGIN {STOP_POSITION="na"} {STOP_POSITION=$FIELD_INDEX} END {print STOP_POSITION}' | read STOP_POSITION
set colsep '|'
set linesize 200
set pagesize 0
set sqlprompt ''
set trimspool on
set headsep off
	ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD HH24:MI:SS';
	SELECT 
		'OUTPUT',
		(first_time - TO_DATE('1970-01-01', 'YYYY-MM-DD')) * 86400
	FROM
		v\$log
	WHERE
		status = 'CURRENT' AND $POSITION >= first_change# ;
EOF
		;;
	esac
		
	echo $STOP_POSITION
}


TAIL_LIMIT=5000


#-------------------------------------------------
# Script START
#-------------------------------------------------
PROGNAME=`basename $0`
SCRIPT_DIR=`dirname $0`
VERSION=`echo "$Revision: 1.0.41 $" | cut -f2 -d' '`

TEMP_FILE_MAIL=/tmp/${PROGNAME}_mail_$$.tmp
TEMP_FILE_BODY=/tmp/${PROGNAME}_body_$$.tmp
TEMP_FILE_AWK=/tmp/${PROGNAME}_awk_$$.tmp
trap clean_up 0


# Read the settings from the properties file
if [ -x ${SCRIPT_DIR}/conf/cdc.properties ]
then
        . ${SCRIPT_DIR}/conf/cdc.properties
else
        log ERROR "$$ Cannot include properties file (${SCRIPT_DIR}/conf/cdc.properties). Exiting!"
        exit 1
fi

# Import general functions
if [ -x  "${SCRIPT_DIR}/include/functions.sh" ]
then
        . "${SCRIPT_DIR}/include/functions.sh"
else
        log ERROR "$$ Cannot include functions file (${SCRIPT_DIR}/include/functions.sh). Exiting!"
        exit 1
fi

NUM_ARGUMENTS=$#

get_args $*
if [ $? != 0 ]
then
        show_help >&2
        log ERROR "$$ Invalid parameters. Exiting!"
        exit 1
fi

if [ "X${SUBSCRIPTION_FLAG}" = "X1" ]
then
	if [ "X${INSTANCE_FLAG}" != "X1" ]
	then
		log ERROR "$$ Option -s can only be used with option -I and a single instance. Exiting!"
		exit 1
	fi
fi

if [ "X${OLDEST_LOG_FILE_FLAG}" != "X1" -o "X${TARGET_HOST_FLAG}" != "X1" -o "X${TARGET_USER_FLAG}" != "X1" -o "X${TARGET_KEY_FLAG}" != "X1" -o "X${TARGET_INSTANCE_FLAG}" != "X1" ]
then
	log ERROR "$$ Options -T, -u, -k, -o and -H are required. Exiting!"
	exit 1
fi

if [ -f ${SCRIPT_DIR}/.oracle_env.sh ]
then
	. ${SCRIPT_DIR}/.oracle_env.sh
fi

ALARM_SUBJECT="Bookmark issue in instance $INSTANCE_NAME. Check body for details."

create_awk
trap clean_up 0


if [ "X${INSTANCE_FLAG}" = "X" ]
then
	#no instances were provided. Get a list of the instances
	INSTANCE_LIST=`retrieveDefinedInstances`
	if [ $? != 0 ]
	then
		log ERROR "$$ Couldn't get a list of instances. Exiting!"
		exit 1
	else
		log INFO "$$ Cheking bookmarks for the instances: ${INSTANCE_LIST}"
	fi
else
	#One or more instances were provided
	if [ "X${INSTANCE_FLAG}" = "X1" ]
	then
		INSTANCE_LIST=$INSTANCE
		#one instance was provided. Did we also get the subscription list?
		if [ "X${SUBSCRIPTION_FLAG}" = "X" ]
		then
			SUBSCRIPTION_LIST=`generate_subs_list $INSTANCE Running`
			if [ $? != 0 ]
			then
				log ERROR "$$ Couldn't get a list of running subscriptions for instance ${INSTANCE_LIST}. Exiting!"
				exit 1
			fi
		else
			SUBSCRIPTION_LIST=`echo ${SUBSCRIPTION_LIST} | sed 's/,/ /g'`
		fi
	else
		if [ "X${INSTANCE_FLAG}" = "X2" ]
		then
			#we gto multiple instances
			INSTANCE_LIST=`echo ${INSTANCE} | sed 's/,/ /g'`
		else
			log ERROR "$$ Invalid value for INSTANCE_FLAG. Exiting"
			exit 1
		fi
	fi
fi
		


DEBUG=0

BOOKMARK_COMMAND=`eval 'echo $SHOWBOOKMARK_COMMAND_'${TARGET_INSTANCE}`
if [ "X${BOOKMARK_COMMAND}" = "X" ]
then
	BOOKMARK_COMMAND=${SHOWBOOKMARK_COMMAND}
	if [ "X${BOOKMARK_COMMAND}" = "X" ]
	then
		log ERROR "$$ Could not obtain SHOWBOOKMARK_COMMAND for target instance (${TARGET_INSTANCE}). Exiting!"
		exit 1
	fi
fi

for INSTANCE_NAME in $INSTANCE_LIST
do
	ALERT_FILE=${SCRIPT_DIR}/tmp/.${PROGNAME}_${INSTANCE_NAME}
	ALERT_FLAG=0

	if [ "X${OLDEST_LOG_FILE_FLAG}" = "X" ]
	then
		OLDEST_LOG_FILE=`eval "echo \$CDC_OLDEST_TX_LOGFILE_${INSTANCE_NAME}"`
		if [ "X${OLDEST_LOG_FILE}" = "X" ]
		then
			OLDEST_LOG_FILE=${CDC_OLDEST_TX_LOGFILE}
			if [ "X${OLDEST_LOG_FILE}" = "X" ]
			then
				log ERROR "$$ Could not obtain oldest open transaction log file for source instance (${INSTANCE_NAME}). Exiting!"
				exit 1
			fi
		fi
	fi

	ORACLE_DEST_ID=`eval 'echo $CDC_ORACLE_DEST_ID_'${INSTANCE_NAME}`
	if [ "X${ORACLE_DEST_ID}" = "X" ]
	then
		ORACLE_DEST_ID=${CDC_ORACLE_DEST_ID}
		if [ "X${ORACLE_DEST_ID}" = "X" ]
		then
			log ERROR "$$ Could not obtain ORACLE_DEST_ID for source instance (${INSTANCE_NAME}). Exiting!"
			exit 1
		fi
	fi
	if [ "X${SUBSCRIPTION_FLAG}" = "X" ]
	then
		SUBSCRIPTION_LIST=`generate_subs_list $INSTANCE_NAME Running`
		if [ $? != 0 ]
		then
			log ERROR "$$ Couldn't get a list of running subscriptions for instance ${INSTANCE_NAME}. Exiting!"
			exit 1
		fi
	fi

	log INFO "$$ Starting bookmark checking for instance ${INSTANCE_NAME}. Subscriptions: ${SUBSCRIPTION_LIST}"
	for SUBSCRIPTION in $SUBSCRIPTION_LIST
	do
		if [ "X${SUBSCRIPTION}" = "Xna" ]
		then
			break
		fi
		CURRENT_DATE=`date +"%Y-%m-%d %H:%M:%S"`

		ssh -i ~/.ssh/${TARGET_KEY} ${TARGET_USER}@${TARGET_HOST} ${BOOKMARK_COMMAND} -I ${TARGET_INSTANCE} -s ${SUBSCRIPTION} -v |  awk -f $TEMP_FILE_AWK | read RESTART_POSITION COMMIT_POSITION

		if [ "X${RESTART_POSITION}" = "Xna" -o "X${COMMIT_POSITION}" = "Xna" ]
		then
			log INFO "$$ Subscription ${SUBSCRIPTION} has no bookmark!" 
			continue
		fi
		log INFO "$$ Subscription: ${SUBSCRIPTION} Restart Position: ${RESTART_POSITION} Commit Position: ${COMMIT_POSITION}"
		get_scn_ts $RESTART_POSITION MAX ARCH | read TXSTART_STOP_INTERVAL

		if [ $DEBUG = 1 ];then log DEBUG "$$ Epoch restart position: ${TXSTART_STOP_INTERVAL}";fi

		tail -${TAIL_LIMIT} ${OLDEST_LOG_FILE} | awk -F '|' -v TXSTART_STOP_INTERVAL=${TXSTART_STOP_INTERVAL} '
BEGIN {
	COMMIT_STOP_INTERVAL="na"
}
{
	if ( $6 > TXSTART_STOP_INTERVAL )
	{
		COMMIT_STOP_INTERVAL=$2
		exit
	}
}

END {
print COMMIT_STOP_INTERVAL
}' | read COMMIT_STOP_INTERVAL

		if [ $DEBUG = 1 ];then log DEBUG "$$ Epoch commit stop interval: ${COMMIT_STOP_INTERVAL}";fi

		if [ "X${COMMIT_STOP_INTERVAL}" = "Xna" ]
		then
			log INFO "$$ Subscription: ${SUBSCRIPTION} Bookmark OK!"
			#Should we send an OK message to the notification alert file?
			continue
		fi

		get_scn_ts $COMMIT_POSITION MIN ARCH | read COMMIT_POSITION_STOP_INTERVAL
		if [ $DEBUG = 1 ];then log DEBUG "$$ Epoch commit position stop interval: ${COMMIT_POSITION_STOP_INTERVAL}";fi
		if [ "X${COMMIT_POSITION_STOP_INTERVAL}" = "Xna" ]
		then
			# initial ts from archived logs not found. Reading online logs
			get_scn_ts $COMMIT_POSITION MIN ONLN | read COMMIT_POSITION_STOP_INTERVAL
			if [ "X${COMMIT_POSITION_STOP_INTERVAL}" = "Xna" ]
			then
				log WARNING "$$ Bookmark issue 1! Subscription online,  TX from restart position already closed and it was not possible to get current log start position"
				echo "${CURRENT_DATE} Bookmark issue 1! Subscription ${SUBSCRIPTION} online,  TX from restart position already closed and it was not possible to get current log start position" >> ${TEMO_FILE_BODY}
				printf "\n\n\n" >>$TEMP_FILE_BODY
				
				# Should send a Warning notification alert?
				alert_notification ${INSTANCE_NAME} DEFAULT ${SUBSCRIPTION} DEFAULT "Warning" "Bookmark" "Bookmark issue (1) in subscription ${SUBCRIPTION}. Subscription online,  TX from restart position already closed and it was not possible to get current log start position"
				ALERT_FLAG=1
			else
				if [ ${COMMIT_POSITION_STOP_INTERVAL} -gt ${COMMIT_STOP_INTERVAL} ]
				then
					log WARNING "${CURRENT_DATE} Bookmark issue 2a! Commit stop interval: ${COMMIT_STOP_INTERVAL} Commit position stop interval: ${COMMIT_POSITION_STOP_INTERVAL}"
					echo "${CURRENT_DATE} Subscription $SUBSCRIPTION seems to have a stuck bookmark:" >> $TEMP_FILE_BODY
					echo "${CURRENT_DATE}      Restart Position: $RESTART_POSITION" >> $TEMP_FILE_BODY
					echo "${CURRENT_DATE}      Commit Position : $COMMIT_POSITION" >> $TEMP_FILE_BODY
					echo "${CURRENT_DATE}      Commit end interval         : $COMMIT_STOP_INTERVAL" >> $TEMP_FILE_BODY
					echo "${CURRENT_DATE}      Commit position end interval: $COMMIT_POSITION_STOP_INTERVAL" >> $TEMP_FILE_BODY
					printf "\n\n\n" >>$TEMP_FILE_BODY
					alert_notification ${INSTANCE_NAME} DEFAULT ${SUBSCRIPTION} DEFAULT "Error" "Bookmark" "Stuck bookmark (2a) in subscription ${SUBCRIPTION}. Restart: ${RESTART_POSITION} Commit: ${COMMIT_POSITION} Commit end interval: ${COMMIT_STOP_INTERVAL} Commit pos. end interval: ${COMMIT_POSITION_STOP_INTERVAL}"
					ALERT_FLAG=1
				else
					log INFO "$$ Bookmark ok(2)! Commit stop interval: ${COMMIT_STOP_INTERVAL} Commit position stop interval: ${COMMIT_POSITION_STOP_INTERVAL}"
					#Should we send an OK message to the notification alert file?
				fi
			fi
		else
			if [ ${COMMIT_POSITION_STOP_INTERVAL} -gt ${COMMIT_STOP_INTERVAL} ]
			then
				log WARNING "$$ Bookmark issue 2b! Commit stop interval: ${COMMIT_STOP_INTERVAL} Commit position stop interval: ${COMMIT_POSITION_STOP_INTERVAL}"
				echo "${CURRENT_DATE} Subscription $SUBSCRIPTION seems to have a stuck bookmark:" >> $TEMP_FILE_BODY
				echo "${CURRENT_DATE}      Restart Position: $RESTART_POSITION" >> $TEMP_FILE_BODY
				echo "${CURRENT_DATE}      Commit Position : $COMMIT_POSITION" >> $TEMP_FILE_BODY
				echo "${CURRENT_DATE}      Commit end interval         : $COMMIT_STOP_INTERVAL" >> $TEMP_FILE_BODY
				echo "${CURRENT_DATE}      Commit position end interval: $COMMIT_POSITION_STOP_INTERVAL" >> $TEMP_FILE_BODY
				printf "\n\n\n" >>$TEMP_FILE_BODY
				alert_notification ${INSTANCE_NAME} DEFAULT ${SUBSCRIPTION} DEFAULT "Error" "Bookmark" "Stuck bookmark (2b) in subscription ${SUBCRIPTION}. Restart: ${RESTART_POSITION} Commit: ${COMMIT_POSITION} Commit end interval: ${COMMIT_STOP_INTERVAL} Commit pos. end interval: ${COMMIT_POSITION_STOP_INTERVAL}"
				ALERT_FLAG=1
			else
				log INFO "$$ Bookmark ok! Commit stop interval: ${COMMIT_STOP_INTERVAL} Commit position stop interval: ${COMMIT_POSITION_STOP_INTERVAL}"
				#Should we send an OK message to the notification alert file?
			fi
		fi
	done

	if [ $ALERT_FLAG = 1 ]
	then
		if [ -r "${ALERT_FILE}" ]
		then
			cat ${ALERT_FILE} | read ALERT_COUNT	
			ALERT_COUNT=`expr ${ALERT_COUNT} + 1`
		else
			ALERT_COUNT=1
		fi
		if [ ${ALERT_COUNT} -le ${ALERT_COUNT_LIMIT} ]
		then
			alert_mail FILE
		fi
		echo ${ALERT_COUNT} > ${ALERT_FILE}
	else
		rm -f ${ALERT_FILE}
	fi
	log INFO "$$ Finished bookmark checking for instance $INSTANCE_NAME"
done

